AutoBuffs = LibStub("AceAddon-3.0"):NewAddon("Autobuffs", "AceConsole-3.0", "AceEvent-3.0")
local ab = AutoBuffs
local rc = LibStub("LibRangeCheck-2.0")
local ldb = LibStub:GetLibrary("LibDataBroker-1.1")

ab.updateperiod = 0.5 -- max time between checks and
ab.elapsed = 0 -- time since last check (seconds)

function ab:OnInitialize()
  local _, class = UnitClass("player")
  if class ~= "DRUID" then return end

  ab.dataobj = ldb:NewDataObject("AutoBuffs", {type = "data source", text = "", icon = "Interface\\Icons\\Spell_Nature_Regeneration"})
  ab.ldbframe = CreateFrame("frame")
  
  ab.ldbframe:SetScript("OnUpdate", function(self, elap)

    -- if we've gone without a check for more than updateperiod seconds, then update
    ab.elapsed = ab.elapsed + elap
    if ab.elapsed > ab.updateperiod then
      ab:Update()
    end

    spell, unitid = ab.GetSpell(), ab.GetTarget()
    if (not unitid) or (unitid == "") then
      ab.dataobj.text = "None"
    else
     	ab.dataobj.text = GetUnitName(unitid, false) .. ": " .. ab:Abbreviate(spell)
    end
  end)
  
  function ab.dataobj:OnTooltipShow()
  	self:AddLine("AutoBuffs:")
    self:AddLine("")
    for k, v in pairs(ab:ListPlayers()) do
      self:AddLine(k .. " " .. v)
    end
  end
  
  function ab.dataobj:OnEnter()
  	GameTooltip:SetOwner(self, "ANCHOR_NONE")
  	GameTooltip:SetPoint("TOPLEFT", self, "BOTTOMLEFT")
  	GameTooltip:ClearLines()
  	dataobj.OnTooltipShow(GameTooltip)
  	GameTooltip:Show()  
  end
  
  function ab.dataobj:OnLeave()
  	GameTooltip:Hide()
  end
  
  SLASH_AUTOBUFFS1 = "/ab1"
  function SlashCmdList.AUTOBUFFS(msg, editbox)
    for k, v in pairs(ab:ListPlayers()) do
      print(k .. " " .. v)
    end
  end
end

function ab:OnEnable()

  local _, class = UnitClass("player")
  if class ~= "DRUID" then return end

  -- disable tracking during combat to try and avoid UNIT_AURA event overload
  ab:EnableEvents()
  ab:RegisterEvent("PLAYER_REGEN_ENABLED")
  ab:RegisterEvent("PLAYER_REGEN_DISABLED")

	ab.frame = CreateFrame("Button", "TestButton", nil, "SecureUnitButtonTemplate")
  -- we use a macro in order not to cast in combat and potential cancel a useful shapeshift.
	ab.frame:SetAttribute("type", "macro")
  ab.frame:SetAttribute("spell", "Mark of the Wild")
	ab.frame:SetAttribute("macrotext", "/cast [nocombat] Mark of the Wild")
	ab.frame:RegisterForClicks("AnyDown",  "AnyUp")
	ab.frame:HookScript("OnClick", 
	  function(self, button) 
      -- we've overridden the current binding, so we run that once we've buffed.
	    pcall(RunBinding, GetBindingAction(button))
	  end
  )
	
	SetOverrideBindingClick(ab.frame, true, "MOUSEWHEELUP", "TestButton", "MOUSEWHEELUP")
end

-- simple functions to modify what the secure button does.
function ab:SetSpell(spell)
  --print("SetSpell: " .. (spell or "nil"))
	ab.frame:SetAttribute("spell", spell)
  ab.UpdateMacro()
end
function ab:SetTarget(unitid)
  ab.frame:SetAttribute("unit", unitid)
  ab.UpdateMacro()
end
function ab:GetSpell()
	return ab.frame:GetAttribute("spell")
end
function ab:GetTarget()
  return ab.frame:GetAttribute("unit")
end

function ab:UpdateMacro()
  spell, unitid = ab:GetSpell(), ab:GetTarget()
  ab.frame:SetAttribute("macrotext", spell and unitid and (spell ~= "") and "/cast [target="..unitid..",nocombat] "..spell or "")
  --print("Setting macrotext to *" .. (ab.frame:GetAttribute("macrotext") or "None") .. "* ")
end

function ab:OnDisable()
    -- Called when the addon is disabled
end

--[[-------------------------------


end of init code, start event stuff


--]]-------------------------------

function ab:EnableEvents()
  self:RegisterEvent("UNIT_AURA", "Update")
  self:RegisterEvent("PLAYER_ENTERING_WORLD", "Update")
  self:RegisterEvent("PLAYER_ALIVE", "Update")
  self:RegisterEvent("PlAYER_UNGHOST", "Update")
end
function ab:DisableEvents()
  self:UnregisterEvent("UNIT_AURA", "Update")
  self:UnregisterEvent("PLAYER_ENTERING_WORLD", "Update")
  self:UnregisterEvent("PLAYER_ALIVE", "Update")
  self:UnregisterEvent("PlAYER_UNGHOST", "Update")
end

function ab:PLAYER_REGEN_DISABLED()
  --print"Disabling event tracking"
  ab:DisableEvents()
end
function ab:PLAYER_REGEN_ENABLED()
  --print"Enabling event tracking"
  ab:EnableEvents()
  ab:Update()
end

function ab:Update()

  ab.elapsed = 0 -- refresh update timer

  local spell, unitid = ab:CheckRaid()

  --print("CheckRaid: " .. (spell or "no spell") .. ", " .. (target or "no target"))

  ab:SetSpell(spell)
  ab:SetTarget(unitid)

end

--[[--------------------------------

logic code (Decides what to do in a given situation)

--]]--------------------------------
	
--[[
  CheckRaid: returns the recommended action and a target if MOTW.
  The action is "Gift of the Wild" or "Mark of the Wild" for now, and target
  is a UnitID (eg "player", "party1", "raid20" etc). Nil for do nothing.

  ATM just returns MOTW on the first player without it.
]]
function ab:CheckRaid()

  survey = ab:ListPlayers()
  numplayers = (GetNumRaidMembers() > 0 and GetNumRaidMembers()) or -- raid
               (GetNumPartyMembers() > 0 and GetNumPartyMembers()) or -- party
               1 -- solo

  -- if everybody is buffed wait
  -- if everybody is here and .. >5 are buffedlow or wanting buffs, then gotw
  --                          .. <5 are buffedlow or wanting buffs, then motw
  -- if <3 people are far away/offline and >5 need a buff, then gotw
  -- else motw anyone left

  if survey.buffed == numplayers then 
    return   
  elseif survey.fakedc + survey.deadjim == 0 then
    if survey.lowbuffed + survey.wantsbuffing < 5 then
      return ab:DoMOTW()
    else
      return "Gift of the Wild", "player"
    end
  elseif survey.fakedc + survey.deadjim < 3 then
    return "Gift of the Wild", "player"
  else
    return ab:DoMOTW()
  end

end

--[[
  Does a MOTW on the first person that needs it
]]
function ab:DoMOTW()
  -- first get a list of players to check based on our current situation
  local playerlist = ab:CreatePlayerList()

  -- now loop through the players we have and check them for buffs.
  for _,unitid in ipairs(playerlist) do
    -- check the player isn't too far away
    local _, maxrange = rc:getRange(unitid)

    hasMOTW, MOTWtimeleft = ab:HasMOTW(unitid)

    if (not hasMOTW or hasMOTW and MOTWtimeleft < 600) and (maxrange and maxrange <= 30) then
      return "Mark of the Wild", unitid
    end
  end
end

--[[
  Check if a player has MOTW or GOTW on them, and, if so, return the time 
  left in seconds on the buff.
]]
function ab:HasMOTW(unitid)

  local i, hasMOTW, MOTWtimeleft = 1, false, 0
  -- iterate through buffs and check for MOTW/GOTW
  local buff, _, _, _, _, _, timeleft = UnitBuff(unitid, i, true);	-- third argument means list only buffs we can cast
  while buff do
    if (buff == "Mark of the Wild") or (buff == "Gift of the Wild") then
      hasMOTW = true
      MOTWtimeleft = timeleft - GetTime()
    end
    i = i + 1
	  buff, _, _, _, _, _, timeleft = UnitBuff(unitid, i, true);
  end

  return hasMOTW, MOTWtimeleft

end

--[[
  Create a player list to iterate over.
]]
function ab:CreatePlayerList()

  local playerlist = {}
  if GetNumRaidMembers() > 0 then -- in a raid
    for i = 1,GetNumRaidMembers() do
      table.insert(playerlist, "raid"..i)
    end
  elseif GetNumPartyMembers() > 0 then -- in a party 
    for i = 1,GetNumPartyMembers() do
      table.insert(playerlist, "party"..i)
    end
  end
  table.insert(playerlist, "player") --[[ solo, also needed for raid/party 
  too - the player isn't included in the raidN/partyN lists ]]

  return playerlist

end

--[[
  Check the state of a player to see if they can be buffed
]]
function ab:CheckState(unitid)

  local hasMOTW, MOTWtimeleft = ab:HasMOTW(unitid) 
  local minrange, maxrange = rc:getRange(unitid)

  if hasMOTW and (MOTWtimeleft < 600) then -- 10mins needs a rebuff
    return "lowbuffed"
  elseif hasMOTW then
    return "buffed"
  elseif not UnitIsConnected(unitid) then
    return "fakedc"
  elseif UnitIsDeadOrGhost(unitid) then
    return "deadjim"
  elseif (not maxrange) or (maxrange > 30) then
    return "farfaraway"
  else
    return "wantsbuffing"
  end

end

--[[
  Create a summary of players in the raid to help decide
  whether to MOTW one or throw out a GOTW
]]
function ab:ListPlayers()

  local playerlist = ab:CreatePlayerList()
  local statelist = {
    lowbuffed = 0, 
    buffed = 0,
    fakedc = 0, 
    deadjim = 0,
    farfaraway = 0,
    wantsbuffing = 0
  }

  for _, unitid in ipairs(playerlist) do
    local state = ab:CheckState(unitid)
    statelist[state] = statelist[state] + 1
  end

  return statelist

end

--[[----------------------------------

  some util functions

--]]----------------------------------

--[[
  Return an acronym for the input text
]]
function ab:Abbreviate(input)

  -- replace every space-separated word with its first letter
  return (string.gsub(input, "(%a)%a*%s*", "%1"))

end

