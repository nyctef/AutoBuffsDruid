
AutoBuffs = LibStub("AceAddon-3.0"):NewAddon("Autobuffs", "AceConsole-3.0", "AceEvent-3.0")
local ab = AutoBuffs
local rc = LibStub("LibRangeCheck-2.0")
local ldb = LibStub:GetLibrary("LibDataBroker-1.1")


--[=[
local options = { 
    name = "Autobuffs",
    handler = ab,
    type = "group",
    args = {
        spell = {
            type = "input",
            name = "Spell",
            desc = "The spell to play around with",
            usage = "<spell>",
            get = "GetSpell",
            set = "SetSpell",
        },
    },
}
]=]

function ab:OnInitialize()
	--LibStub("AceConfig-3.0"):RegisterOptionsTable("WelcomeHome", options, {"autobuffs", "ab"})

ab.dataobj = ldb:NewDataObject("AutoBuffs", {type = "data source", text = "", icon = "Interface\\Icons\\Spell_Nature_Regeneration"})
ab.ldbframe = CreateFrame("frame")

ab.ldbframe:SetScript("OnUpdate", function(self, elap)
  spell, unitid = ab.GetSpell(), ab.GetTarget()
  if (not unitid) or (unitid == "") then
    ab.dataobj.text = "None"
  else
  	ab.dataobj.text = GetUnitName(unitid, false) .. ": " .. ab:Abbreviate(spell)
  end
end)

function ab.dataobj:OnTooltipShow()
	self:AddLine("AutoBuffs:")
  self:AddLine("")
  for k, v in pairs(ab:ListPlayers()) do
    self:AddLine(k .. " " .. v)
  end
end

function ab.dataobj:OnEnter()
	GameTooltip:SetOwner(self, "ANCHOR_NONE")
	GameTooltip:SetPoint("TOPLEFT", self, "BOTTOMLEFT")
	GameTooltip:ClearLines()
	dataobj.OnTooltipShow(GameTooltip)
	GameTooltip:Show()
end

function ab.dataobj:OnLeave()
	GameTooltip:Hide()
end


SLASH_AUTOBUFFS1 = "/ab1"
function SlashCmdList.AUTOBUFFS(msg, editbox)
  for k, v in pairs(ab:ListPlayers()) do
    print(k .. " " .. v)
  end
end
end

function ab:OnEnable()

  -- disable tracking during combat to try and avoid UNIT_AURA event overload
  ab:EnableEvents()
  ab:RegisterEvent("PLAYER_REGEN_ENABLED")
  ab:RegisterEvent("PLAYER_REGEN_DISABLED")

	ab.frame = CreateFrame("Button", "TestButton", nil, "SecureUnitButtonTemplate")
  -- we use a macro in order not to cast in combat and potential cancel a useful shapeshift.
	ab.frame:SetAttribute("type", "macro")
  ab.frame:SetAttribute("spell", "Mark of the Wild")
	ab.frame:SetAttribute("macrotext", "/cast [nocombat] Mark of the Wild")
	ab.frame:RegisterForClicks("AnyDown",  "AnyUp")
	ab.frame:HookScript("OnClick", 
	  function(self, button) 
      -- we've overridden the current binding, so we run that once we've buffed.
	    pcall(RunBinding, GetBindingAction(button))
	  end
  )
	
	SetOverrideBindingClick(ab.frame, true, "MOUSEWHEELUP", "TestButton", "MOUSEWHEELUP")
end

-- simple functions to modify what the secure button does.
function ab:SetSpell(spell)
  --print("SetSpell: " .. (spell or "nil"))
	ab.frame:SetAttribute("spell", spell)
  ab.UpdateMacro()
end
function ab:SetTarget(unitid)
  ab.frame:SetAttribute("unit", unitid)
  ab.UpdateMacro()
end
function ab:GetSpell()
	return ab.frame:GetAttribute("spell")
end
function ab:GetTarget()
  return ab.frame:GetAttribute("unit")
end

function ab:UpdateMacro()
  spell, unitid = ab:GetSpell(), ab:GetTarget()
  ab.frame:SetAttribute("macrotext", spell and unitid and (spell ~= "") and "/cast [target="..unitid..",nocombat] "..spell or "")
  --print("Setting macrotext to *" .. (ab.frame:GetAttribute("macrotext") or "None") .. "* ")
end

function ab:OnDisable()
    -- Called when the addon is disabled
end

--[[-------------------------------


end of init code, start event stuff


--]]-------------------------------

function ab:EnableEvents()
  self:RegisterEvent("UNIT_AURA", "Update")
  self:RegisterEvent("PLAYER_ENTERING_WORLD", "Update")
  self:RegisterEvent("PLAYER_ALIVE", "Update")
  self:RegisterEvent("PlAYER_UNGHOST", "Update")
end
function ab:DisableEvents()
  self:UnregisterEvent("UNIT_AURA", "Update")
  self:UnregisterEvent("PLAYER_ENTERING_WORLD", "Update")
  self:UnregisterEvent("PLAYER_ALIVE", "Update")
  self:UnregisterEvent("PlAYER_UNGHOST", "Update")
end

function ab:PLAYER_REGEN_DISABLED()
  --print"Disabling event tracking"
  ab:DisableEvents()
end
function ab:PLAYER_REGEN_ENABLED()
  --print"Enabling event tracking"
  ab:EnableEvents()
  ab:Update()
end

function ab:Update()

  local spell, unitid = ab:CheckRaid()

  --print("CheckRaid: " .. (spell or "no spell") .. ", " .. (target or "no target"))

  ab:SetSpell(spell)
  ab:SetTarget(unitid)

end

--[[--------------------------------

logic code (Decides what to do in a given situation)

--]]--------------------------------
	
--[[
  CheckRaid: returns the recommended action and a target if MOTW.
  The action is "Gift of the Wild" or "Mark of the Wild" for now, and target
  is a UnitID (eg "player", "party1", "raid20" etc). Nil for do nothing.

  ATM just returns MOTW on the first player without it.
]]
function ab:CheckRaid()

  -- first get a list of players to check based on our current situation
  local playerlist = ab:CreatePlayerList()

  -- now loop through the players we have and check them for buffs.
  for _,unitid in ipairs(playerlist) do
    -- check the player isn't too far away
    local _, maxrange = rc:getRange(unitid)

    if (not ab:HasMOTW(unitid)) and (maxrange and maxrange <= 30) then
      return "Mark of the Wild", unitid, maxrange, UnitName(unitid)
    end
  end

end

--[[
  Check if a player has MOTW or GOTW on them, and, if so, return the time 
  left in seconds on the buff.
]]
function ab:HasMOTW(unitid)

  local i, hasMOTW, MOTWtimeleft = 1, false, 0
  -- iterate through buffs and check for MOTW/GOTW
  local buff, _, _, _, _, _, timeleft = UnitBuff(unitid, i, true);	-- third argument means list only buffs we can cast
  while buff do
    if (buff == "Mark of the Wild") or (buff == "Gift of the Wild") then
      hasMOTW = true
      MOTWtimeleft = timeleft
    end
    i = i + 1
	  buff, _, _, _, _, _, timeleft = UnitBuff(unitid, i, true);
  end

  return hasMOTW, MOTWtimeleft

end

--[[
  Create a player list to iterate over.
]]
function ab:CreatePlayerList()

  local playerlist = {}
  if GetNumRaidMembers() > 0 then -- in a raid
    for i = 1,GetNumRaidMembers() do
      table.insert(playerlist, "raid"..i)
    end
  elseif GetNumPartyMembers() > 0 then -- in a party 
    for i = 1,GetNumPartyMembers() do
      table.insert(playerlist, "party"..i)
    end
  end
  table.insert(playerlist, "player") --[[ solo, also needed for raid/party 
  too - the player isn't included in the raidN/partyN lists ]]

  return playerlist

end

--[[
  Check the state of a player to see if they can be buffed
]]
function ab:CheckState(unitid)

  local hasMOTW, MOTWtimeleft = ab:HasMOTW(unitid) 
  local minrange, maxrange = rc:getRange(unitid)

  if hasMOTW and (MOTWtimeleft < 600) then -- rebuff at 10mins
    return "lowbuffed"
  elseif hasMOTW then
    return "buffed"
  elseif not UnitIsConnected(unitid) then
    return "offline"
  elseif UnitIsDeadOrGhost(unitid) then
    return "deadjim"
  elseif (not maxrange) or (maxrange > 30) then
    return "farfaraway"
  else
    return "wantsbuffing"
  end

end

--[[
  Create a summary of players in the raid to help decide
  whether to MOTW one or throw out a GOTW
]]
function ab:ListPlayers()

  local playerlist = ab:CreatePlayerList()
  local statelist = {
    lowbuffed = 0, 
    buffed = 0,
    offline = 0, 
    deadjim = 0,
    farfaraway = 0,
    wantsbuffing = 0
  }

  for _, unitid in ipairs(playerlist) do
    local state = ab:CheckState(unitid)
    statelist[state] = statelist[state] + 1
  end

  return statelist

end

--[[----------------------------------

  some util functions

--]]----------------------------------

--[[
  Return an acronym for the input text
]]
function ab:Abbreviate(input)

  return (string.gsub(input, "(%a)%a*%s*", "%1"))

end

